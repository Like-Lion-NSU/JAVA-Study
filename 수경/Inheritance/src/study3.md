<h2>상속</h2>
- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 상속에는 상속관계와 포함관계가 있다. 
> 상속관계: '~은 ~이다(is-a)'
> 포함관계: '~은 ~을 가지고 있다.(has-is)' 

>장점
> <ol>
> <li>적은 양의 코드로 새로운 클래스를 작성할 수 있다.</li>
> <li>코드의 수정 및 변경이 매우 용이하다.</li>
> <li>프로그램 생산설, 유지보수에 크게 기여한다.</li>
> </ol>


|클래스|       명칭       |
|:------:|:--------------:|
|조상 클래스| 부모 클래스, 상위 클래스 |
|자손 클래스| 자식 클래스, 하위 클래스 |

ex) 상속해주는 클래스를 '조상 클래스'라 하고 상속받는 클래스를 '자손 클래스'라 한다.
class 자손클래스명 **extends** 조상클래스명{...}

-자손 클래스는 조상 클래스의 모든 멤버를 상속받는다. 
-만일 조상 클래스에 age라는 정수형 변수를 멤버변수로 추가하면, 자동적으로 자손 클래스에 멤버변수가 추가된다.
-자손 클래스에 새로운 코드가 추가되어도 조상 클래스는 아무런 영향을 받지 않는다.
-자손 클래스 멤버개수 >= 조상 클래스 멤버개수

참고! 
접근 제어자가 private 또는 default인 멤버들은 상속 받지만 자손 클래스의 접근이 제한된다.

<h3>단일 상속(single inheritance)</h3>
- 자바는 오직 단일 상속만을 허용한다.
- 클래스간의 관계가 매우 복잡해진다.
- 서로 다른 클래스로부터 상속 받는 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없다.

ex)class TVCR extends TV, VCR{ //에러. 조상은 하나만 허용한다.}

위에 예제는 포함관계를 사용해 해결 할 수 있다.
TV클래스와 CR클래스를 각각 만든다음 인스턴스를 생성하여 사용하는 것이다.

<h3>Object클래스 - 모든 클래스의 조상</h3>
- Object클래스는 모든 클래스 상속계층도의 **최상위**에 있는 조상 클래스다.
- 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받는다
>toString(), equals()이 메서드 들이 Object클래스에 정의되어 있었기 때문에 정의하지 않고 쓸 수 있었다.
***

<h2>오버라이딩(Overriding)</h2>
- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
- 자손 클래스에 맞게 변경해야하는 경우에 사용한다.-

      class Point{d
           int x;
           int y;

           String getLocation(){
                return "x :"+ x + ", y :" + y;
           }
      }
           
      class Point3D extends Point(){
           int z;

           String getLocation(){
                 return "x :"+ x + ", y :" + y + ". z:" + z;
           }
      }


<h3>오버라이딩 조건</h3>
>자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
> - 이름이 같아야 한다.
> - 매개변수가 같아야 한다.
> - 반환타입이 같아야 한다.
>1. 접근 제어자는 조상 클랫의 메서드보다 좁은 범위로 변경할 수 없다.(public, protected, (default), private)
>2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

>조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
> - 안스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.

<h3>super</h3>
- 자손 클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용하는 참조변수이다.
- 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.
> static메서드에서는 사용할 수 없고 인스턴스메서드에서만 사용할 수 있다.
 
    class SuperTest{
       public static void main(String args[]){
          Child c = new Child();
          c.method();
       }
    }
    
    class Parent{
       int x=10;
    }
    
    class Cjild extends Parent{
       void method(){
          System.out.println("x=" + x);
          System.out.println("this.x=" + this.x);
          System.out.println("super.x=" + super.x);
       }
    }
<h4>위 예제는 x, this.x, super.x 모두 같은 변수를 의미하므로 모두 같은 값이 출력된다.</h4>

<h3>super() - 조상 클래스의 생성자</h3>
- 조상 클래스의 생성자를 호출하는데 사용된다.
- 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수 있으므로 조상의 멤버들이 먼저 초기화되어 있어야 되기 때문에 조상클래스를 호출하느 이유다.

<ol>
<li>클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?</li>
<li>생성자 - 선택할 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?</li>
</ol>

***

<h2>static - 클래스의, 공통적인</h2>
- 하나의 변수를 모든 인스턴스가 공유해서 클래스변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 갖는다.
>static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

|  제어자   |  대상  | 의미                                                                                              |
|:------:|:----:|:------------------------------------------------------------------------------------------------|
| static | 멤버변수 | - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.<br/>- 클래스변수는 인스턴스를 생성하지 않고도 사용 가능하다.<br/>- 클래스가 메모리에 로드될 때 생성된다. |
|    "    | 메서드  | - 인스턴스를 생성하지 않고도 호출이 가능한 static메서드가 된다.<br/>- static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.|


<h2>final - 마지막의, 변경될 수 없는</h2>
- 변수에 사용되면 값을 변경할 수 없는 상수가 된다.
- 메서드에 사용되면 오버라이딩을 할 수 없다.
- 클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.
>final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

***
<h2>abstract - 추상의, 미완성의</h2>

- 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.


|   제어자    | 대상  | 의미                                  |
|:--------:|:----|:------------------------------------|
| abstract | 클래스 | 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.|
|"| 메서드 | 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.|

>abstract가 사용될 수 있는 곳 - 클래스, 메서드

<h3>추상클래스</h3>
- 추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.
- 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'이므로 인스턴스를 생성할 수 없다.

      //추상클래스 구현 방법: 키워드'abstract'를 붙여주면 된다!

      abstract class 클래스이름{
        ...
      }
>추상클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있다.

<h3>추상메서드</h3>
- 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨둔 것
>메서드는 선언부와 구현부(몸통)로 구성되어 있다.
- 메서드 내용이 상속받은 클래스에 따라 달라질 수 있기에 추상메서드를 사용한다.

      //추상메서드 구현 방법: 키워드'abstract'를 붙여 주고, 구현부가 없으므로 {}대신 문장의 끝을 알리는 ';'을 적어준다.

      abstract 리턴타입 메서드이름();
***

<h2>인터페이스(interface)</h2>
- 일종의 추상클래스이다.
- 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 다른 어떠한 요소도 허용하지 않는다.
- 완성되지 않아 그 자체만으로 사용되기 보다는 다른 클래스를 작성하는데 도움 줄 목적으로 작성된다.
- 구현된 것은 아무덧도 없고 밑그림만 그려져 있는 '기본 설계도'라 한다.

<h3>인터페이스의 작성</h3>
- class작성하는 것과 같지만 키워드 'class'대신 'interface'를 사용한다.

      interface 인터페이스이름{
            public static final 타입 상수이름 = 값;
            public abstract 메서드이름(매개변수목록);
      }

>인터페이스의 멤버 제약사항!!
> - 모든 멤버변수는 pubic static final 이어야 하며, 이를 생략할 수 있다.
> - 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.

<h3>인터페이스의 상속</h3>
- 인터페이스는 인터페이스로부터만 상속 받을 수 있다.
- 다중상속 즉 여러 개의 인터페이스로부터 상속을 받는 것이 가능하다.
- 클래스와 달리 Object클래스와 같은 최고 조상이 없다.

<h3>인터페이스 구현</h3>
- 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없다.
- 인터페이스는 구현한다는 의미의 키워드'implements'를 사용한다. (키워드'extends'아님!)

      //Fighter클래스는 Fightable인터페이스를 구현한다.
      class 클래스이름 implements 인터페이스이름{
            //인터페이스에 정의된 추상메서드를 구현해야 한다.
      }
      class Figter implements Fightable{
           public void move(int x, int y){ /* 내용생략 */ }
           public void attack(Unit u){ /* 내용생략 */ }
      }
<br>

- 구현하는 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야 한다.

      abstract class Fighter implements Fightable{
           public void move(int x, int y){/* 내용생략 */}
      }
<br>

- 상속과 구현을 동시에 할 수 있다.

      class Fighter extends Unit implements Fightable{
          public void move(int x, int y){ /* 내용생략 */ }
          public void attack(Unit u){ /* 내용생략 */ }
      }

***
<h2>instanceof연산자</h2>
- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다.
- 주로 조건문에 사용된다.
- 참조변수 instanceof 타입(클래스명) 
- 연산의 결과로 boolean값인 true와 false 중의 하나를 반환한다.
>instanceof를 이용한 연산결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻함

    void doWork(Car c){
        if(c instanceof FireEngine){
            FireEngine fe = (FireEngine)c;
            fe.water();
              ...
        } else if(c instanceof Ambulance){
            Ambulance a = (Ambulance)c;
            a.siren();
                ...
        }
          ...
    }
>Car타입의 참조변수 c를 매개변수로 하는 메서드이다.
> 미 메서드가 호출될 때, 매개변수로 Car또는 그 자손 클래스의 인스턴스을 넘겨받겠지만 메서드 내에서는 정확히 어떤 인스턴스인지를 알 길이 없다.
> 그래서 instanceof연산자를 이용해서 참조변수 c가 가리키고 있는 인스턴스의 타입을 체크하고, 적절히 형변환한 다음에 작업을 해야한다.

***

