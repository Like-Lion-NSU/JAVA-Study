- 상속(o,x)
    1. 자바는 다중 상속을 허용한다.>> X
    2. 부모의 메소드를 자식 클래스에서 재정의(오버라이딩)할 수 있다.>> O
    3. 부모의 private 접근 제한을 갖는 필드와 메소드는 상속의 대상이 아니다.>> X
    *4. protected 멤버는 같은 패키지의 모든 클래스와 다른 패키지의 자식 클래스만 접근할 수 있다.>> O
    
- 메소드 재정의(오버라이딩)(o,x)
    1. 부모의 메소드는 숨김 효과가 나타난다.>> O
    2. 재정의 시 접근 제한을 더 강하게 할 수 있다.>> X
    3. @Override를 붙이면 컴파일러가 재정의를 확인한다.>> O
    4. 부모 메소드를 호출하고 싶다면 super 키워드를 사용할 수 있다.>> O
    
- final 클래스, 필드, 메소드 (o,x)
    *1. 모두 상속과 관련이 있다.>> x
    2. final 메소드를 가진 클래스는 부모 클래스가 될 수 없다.>> O
    3. final 메소드는 재정의를 할 수가 없다.>> O
    4. final 클래스는 final 필드가 반드시 있어야 한다.>> X
    
    ----------------------------------------------------------------------------------------------------
  
    
class Human{
    String name;
    int age;
    String school;

     Human(String name, int age){   //생성자라 void안됨
        this.name = name;
        this.age = age;
    }

    void output(){
        System.out.println("이름: "+ name);
        System.out.println("나이: "+ age);
    }
}

class Student extends Human{ //생성자는 변수를 초기화해줌
    String school;
    public Student(String name, int age, String school){
        super(name, age);   //super()은 생성자라 무조건 맨앞에 적어야한다!
        this.school = school;
    }

    void output(){
        super.output();
        System.out.println("학교: "+school);
    }


}

class Worker extends Human{
    String job;
    public Worker(String name, int age, String job){
        super(name, age);
        this.job = job;
    }

    void output(){
        super.output();
        System.out.println("직업: "+job);
    }

}

public class StudyQ {

        public static void main(String[] args) {

            Student student = new Student("서송현", 20, "남서울대");
            Worker worker = new Worker("아이유", 39, "가수");

            student.output();
            worker.output();

        }
}
